<div class="well well-small" style="text-align:left">
    <h4><a href="#" title="Оптимизация высоконагруженных веб-систем">Особенности высоконагруженных WEB систем</a></h4>
    <img src="{{ asset('bundles/spbsymfony/images/carousel/optimization.jpg') }}" alt="business templates" /><br/><br/>
    <h4>Система начинается с данных</h4>
    <p>Не секрет что разработка практически любой автоматизированной системы начинается с определения формата входных и выходных данных. Данные могут существенно отличаться по своей структуре и организации. Одни могут иметь множественные связи, другие представлять собой просто массив простых типов данных.</p>
    <p>Нас в первую очередь интересуют два подхода к хранению и работе с данными SQL и NoSQL.</p>
    <p><strong> SQL</strong> (Structured Query Language) — язык структурированных запросов, применяемый для создания, модификации и управления данными в реляционных базах данных, основанных на реляционной модели данных. Думаю, подробно останавливаться на рассмотрении одноименного подхода не стоит, так как это первое с чем сталкивается любой, при изучении баз данных.</p>
    <p><strong> NoSQL</strong> (not only SQL, не только SQL) — ряд подходов, направленных на реализацию моделей баз данных, имеющих существенные отличия от средств языка SQL, характерного для традиционных реляционных баз данных.</p>
    <p>Термин <strong> <em> NoSQL</em> </strong> был придуман Эриком Эвансом, когда Джоан Оскарсон из Last.fm хотел организовать мероприятие для обсуждения распределенных баз данных с открытым исходным кодом.</p>
    <p>Концепция NoSQL не является полным отрицанием языка SQL и реляционной модели. NoSQL — это важный и полезный, но не универсальный инструмент. Одна из проблем классических реляционных БД — это сложности при работе с данными очень большого объема и в высоконагруженных системах. Основная цель  NoSQL — расширить возможности БД там, где SQL недостаточно гибок, не обеспечивает должной производительности, и не вытеснять его там, где он отвечает требованиям той или иной задачи.</p>
    <p>В июле 2011 компания Couchbase, разработчик  CouchDB, Memcached и  Membase, анонсировала создание нового SQL-подобного  языка запросов —  UnQL (Unstructured Data Query Language). Работы по созданию нового языка выполнили создатель  SQLite Ричард Гипп (Richard Hipp) и основатель проекта CouchDB Дэмиен Кац ( Damien Katz). Разработка передана сообществу на правах  общественного достояния</p>
    <p>Использование подхода NoSQL пригодятся нам для хранения огромных массивов простой неструктурированной информации, которая не требует связи с другими данными. Примером такой информации может служить многомиллионный список файлов кэшей или изображений. При этом, мы получим значительный выигрыш в производительности по сравнению с реляционным подходом.</p>
    <h3>NoSQL системы</h3>
    <h5>NoSQL СУБД</h5>
    <p>Определимся с понятиями.</p>
    <p>Масштабируемость — автоматическое распределение данных между несколькими серверами. Такие системы мы называем распределенные базы данных. В них входят Cassandra, HBase, Riak, Scalaris и Voldemort. Если вы используете объем данных, который не может быть обработан на одной машине или если вы не хотите управлять распределением вручную, то это то, что вам нужно.</p>
    <p>Следует обратить внимание на следующие вещи: поддержка нескольких датацентров и возможность добавления новых машин в работающий кластер прозрачно для ваших приложений.</p>
    <table class="table table-striped  table-bordered table-hover table-condensed">
        <tbody>
            <tr>
                <td>
                    &nbsp;
                </td>
                <td>
                    Прозрачное добавление машины в кластер
                </td>
                <td>
                    Поддержка нескольких датацентров
                </td>
            </tr>
            <tr>
                <td>
                    Cassandra
                </td>
                <td>
                    X
                </td>
                <td>
                    X
                </td>
            </tr>
            <tr>
                <td>
                    HBase
                </td>
                <td>
                    X
                </td>
                <td>
                    &nbsp;
                </td>
            </tr>
            <tr>
                <td>
                    Riak
                </td>
                <td>
                    X
                </td>
                <td>
                    X
                </td>
            </tr>
            <tr>
                <td>
                    Scalaris
                </td>
                <td>
                    X
                </td>
                <td>
                    &nbsp;
                </td>
            </tr>
            <tr>
                <td>
                    Voldemort
                </td>
                <td>
                    &nbsp;
                </td>
                <td>
                    Необходимо доработать напильником
                </td>
            </tr>
        </tbody>
    </table>
    <p><br> К нераспределенным базам данных относятся: <em> CouchDB, MongoDB, Neo4j, Redis и </em> <em> Tokyo </em> <em> Cabinet</em> . Эти системы можно использовать в качестве «прослойки» для распределенных систем.</p>
    <h5>Модель данных и запросов</h5>
    <p>Существует огромное количество моделей данных и API запросов в NoSQL базах данных.</p>
    <table class="table table-striped  table-bordered table-hover table-condensed">
        <tbody>
            <tr>
                <td>
                    &nbsp;
                </td>
                <td>
                    Модель данных
                </td>
                <td>
                    API запросов
                </td>
            </tr>
            <tr>
                <td>
                    Cassandra
                </td>
                <td>
                    Семейство столбцов
                </td>
                <td>
                    Thrift
                </td>
            </tr>
            <tr>
                <td>
                    CoutchDB
                </td>
                <td>
                    Документы
                </td>
                <td>
                    Map / Reduce
                </td>
            </tr>
            <tr>
                <td>
                    HBase
                </td>
                <td>
                    Семейство столбцов
                </td>
                <td>
                    Thrift, REST
                </td>
            </tr>
            <tr>
                <td>
                    MongoDB
                </td>
                <td>
                    Документы
                </td>
                <td>
                    Cursor
                </td>
            </tr>
            <tr>
                <td>
                    Neo4j
                </td>
                <td>
                    Графы
                </td>
                <td>
                    Graph
                </td>
            </tr>
            <tr>
                <td>
                    Redis
                </td>
                <td>
                    Коллекции
                </td>
                <td>
                    Collection
                </td>
            </tr>
            <tr>
                <td>
                    Riak
                </td>
                <td>
                    Документы
                </td>
                <td>
                    Nested hashes, REST
                </td>
            </tr>
            <tr>
                <td>
                    Scalaris
                </td>
                <td>
                    Ключ / Значение
                </td>
                <td>
                    Get / Put
                </td>
            </tr>
            <tr>
                <td>
                    Tokyo Cabinet
                </td>
                <td>
                    Ключ / Значение
                </td>
                <td>
                    Get / Put
                </td>
            </tr>
            <tr>
                <td>
                    Voldemort
                </td>
                <td>
                    Ключ / Значение
                </td>
                <td>
                    Get / Put
                </td>
            </tr>
        </tbody>
    </table>
    <p><br> Система семейства столбцов (column family) используется в Cassandra и HBase. В обеих системах, у вас есть строки и столбцы, но количество строк не велико: каждая строка имеет переменное число столбцов и столбцы не должны быть определены заранее.</p>
    <p>Система ключ/значения простая, и не сложна в реализации, но не эффективна, если вы заинтересованы в запросе или обновлении только части данных. Также трудно реализовать сложные структуры поверх распределенных систем этого типа.</p>
    <p>Документно-ориентированные базы данных — это по существу следующий уровень систем ключ/значение, позволяющие связывать вложенные данные с ключом. Поддержка таких запросов более эффективна, чем просто возвращение всего значения.</p>
    <p>Neo4J обладает уникальной моделью данных, которая описывает объекты в виде узлов и ребер графа. Для запросов, которые соответствуют этой модели (например, иерархических данных) производительность может оказаться выше на несколько порядков, чем для альтернативных вариантов.</p>
    <p>Scalaris уникальна в части использования распределенных транзакций между несколькими ключами.</p>
    <h5>Система хранения данных</h5>
    <p>Это вид, в котором данные представлены в системе.</p>
    <table class="table table-striped  table-bordered table-hover table-condensed">
        <tbody>
            <tr>
                <td>
                    &nbsp;
                </td>
                <td>
                    Вид данных
                </td>
            </tr>
            <tr>
                <td>
                    Cassandra
                </td>
                <td>
                    Memtable / SSTable
                </td>
            </tr>
            <tr>
                <td>
                    CoutchDB
                </td>
                <td>
                    Append-only B-Tree
                </td>
            </tr>
            <tr>
                <td>
                    HBase
                </td>
                <td>
                    Memtable / SSTable on HDFS
                </td>
            </tr>
            <tr>
                <td>
                    MongoDB
                </td>
                <td>
                    B-Tree
                </td>
            </tr>
            <tr>
                <td>
                    Neo4j
                </td>
                <td>
                    On-disk linked list
                </td>
            </tr>
            <tr>
                <td>
                    Redis
                </td>
                <td>
                    In-memory with background snapshots
                </td>
            </tr>
            <tr>
                <td>
                    Riak
                </td>
                <td>
                    Hash
                </td>
            </tr>
            <tr>
                <td>
                    Scalaris
                </td>
                <td>
                    In-memory only
                </td>
            </tr>
            <tr>
                <td>
                    Tokyo Cabinet
                </td>
                <td>
                    Hash or B-Tree
                </td>
            </tr>
            <tr>
                <td>
                    Voldemort
                </td>
                <td>
                    Pluggable (primarily BDB MySQL)
                </td>
            </tr>
        </tbody>
    </table>
    <p><br> Система хранения данных может помочь при оценке нагрузок.</p>
    <p>Системы, хранящие данные в памяти, очень-очень быстрые, но не могут работать с данными превышающими размер доступной оперативной памяти. Сохранность таких данных при сбое или отключении питания может стать проблемой. Количество данных которые могут ожидать записи на может быть очень велико. Некоторые системы, например Scalaris, решают данную проблему с помощью репликации, но Scalaris не поддерживает масштабирование на несколько датацентров.</p>
    <p>Memtables / SSTables буферизируют запросы на запись в памяти (Memtable), а после записи добавляют в лог. После накопления достаточного количества записей, Memtable сортируется и записывается на диск, как SSTable. Это позволяет добиться производительности близкой к производительности оперативной памяти, в тоже время избавиться от проблем, актуальных при хранении только в памяти.</p>
    <p>B-деревья используются в базах данных уже очень давно. Они обеспечивают надежную поддержку индексирования, однако производительность, при использовании на машинах с магнитными жесткими дисками, очень низкая.<br> Интересным является использование в CouchDB B-деревьев, только с функцией добавления (append-only B-Trees), что позволяет получить хорошую производительность при записи данных на диск. Достигается это тем, что бинарное дерево не нужно перестраивать при добавлении элемента.</p>
    <p>Отдельного рассмотрения заслуживает проект <strong> Memcached</strong> , ставший прародителем для множества других систем.</p>
    <p><strong> Memcached</strong> — программное обеспечение для кэширования данных в оперативной памяти сервера на основе парадигмы хеш-таблицы. Это высокопроизводительная распределенная система кэширования объектов в оперативной памяти, предназначенная для высоконагруженных интернет-систем.</p>
    <p><em> Хеш-таблица — это  структура данных, реализующая интерфейс  ассоциативного массива, позволяющая хранить пары (ключ, значение) и выполнять три операции: операцию добавления новой пары, операцию поиска и операцию удаления пары по ключу. </em></p>
    <p>С помощью клиентской библиотеки <strong> Memcached</strong> позволяет кэшировать данные в оперативной памяти из множества доступных серверов. Распределение реализуется путем сегментирования данных по значению хэша ключа по аналогии с сокетами хэш-таблицы. Клиентская библиотека, используя ключ данных, вычисляет хэш и использует его для выбора соответствующего сервера. Ситуация сбоя сервера трактуется как промах кэша, что позволяет повышать отказоустойчивость комплекса за счет наращивания количества memcached серверов и возможности производить их горячую замену.</p>
    <p>Memcached имеет множество модификаций, развиваемых в рамках нескольких проектов: <em> Mycached, membase, Memcache, MemcacheQ, Memcacheddb</em> и <em> libMemcached</em> .</p>
    <p>Центральный проект, локомотив концепции NoSQL — Memcached. Один из самых существенных минусов Memcached состоит в том, что сам кэш — весьма ненадежное место хранения данных. Устранить этот недостаток и призваны дополнительные решения: Memcacheddb и  membase.  На уровне интерфейса (API) эти продукты полностью совместимы с Memcached. Но здесь, при устаревании данных, они сбрасываются на диск (стратегия «<code> db checkpoint</code> »). В таком виде они представляют собой яркий пример «нереляционных баз данных» — персистентных (долговременных) систем распределённого хранения данных в виде пар «ключ-значение».</p>
    <p>Следующий продукт, на основе Memcached —  MemcacheQ. Это система очередей сообщений, в которой используется очень упрощенный API от Memcached. MemcacheQ образует именованный стек, куда можно записать свои сообщения, а сами данные физически хранятся в  БД BerkeleyDB (аналогично Memcacheddb), следовательно, обеспечиваются сохранность, возможность реплицирования и прочее.</p>
    <p>LibMemcached — это известная клиентская библиотека, написанная на С++, для работы с уже стандартным протоколом Memcached.</p>
    <p>Все нереляционные хранилища, выполненные в виде распределенной системы и хранящие пары «ключ-значение», можно подразделить на два типа: устойчивые и неустойчивые. <strong> Устойчивые</strong> (например, <em> MemcachedB, membase, Hypertable</em> ) — записывают данные на диск, обеспечивая их сохранность в случае сбоя. <strong> Неустойчивые</strong> (классический Memcached) — хранят ключи в энергозависимой памяти и не гарантируют их сохранность. Неустойчивые хранилища оправдано использовать для кеширования и снижения нагрузки на устойчивые — в этом их неразрывная связь и главное преимущество.</p>
    <p>Устойчивые хранилища – это уже полноценные NoSQL базы данных, которые совмещают в себе скорость работы Memcached и позволяют хранить более сложные данные.</p>
    <h4>Схема frontend+backend</h4>
    <p>Самая распространенная схема, при которой в роли frontend выступает быстрый и легкий web сервер (например Nginx), а в качестве backend работает Apache.</p>
    <p>Давайте рассмотрим преимущества такой схемы на примере. Представим, что web серверу Apache необходимо обслужить порядка 1000 запросов одновременно, причем многие из этих клиентов подключены к интернету по медленным каналам связи. В случае использования Apache мы получим 1000 процессов httpd, на каждый из которых будет выделена оперативная память, и эта память будет занята до тех пор, пока клиент не получит запрошенный контент или не возникнет ошибка.</p>
    <p>В случае применения схемы frontend+backend, после того как пришел запрос клиента, Nginx передает запрос Apache и быстро получает ответ. А в случае со статическим контентом (html, картинки, файлы кеша и пр.) Nginx самостоятельно сформирует ответ, не потревожив Apache. Если нам все-таки нужно выполнить логику (php-скрипт), Apache после того как сделал это и отдал ответ Nginx освобождает память, далее с клиентом взаимодействует web сервер Nginx, который как раз и предназначен для раздачи статического контента, большому количеству клиентов, при незначительном потреблении системных ресурсов. В купе с грамотным кэшированием, получаем колоссальную экономию ресурсов сервера и систему, которую по праву можно назвать высоконагруженной.</p>
    <h5>Рабочие лошадки</h5>
    <h3>Apache - оптимизация производительности</h3>
    <p>Для схемы frontend+backend производительность Apache не стоит столь остро, но если Вам дорога каждая микросекунда процессорного времени и каждый байт оперативной памяти, то следует уделить внимание этому вопросу.</p>
    <p>Самый «крутой» способ – увеличить производительность сервера – поставить более шустрый процессор(ы) и побольше памяти, но мы с Вами пойдем по менее радикальному пути для начала. Ускорим работу Apache путем оптимизации его конфигурации. Существуют конфигурации, которые можно применить только при пересборке Apache, другие же можно применять без перекомпиляции сервера.</p>
    <h5>Загружайте только необходимые модули</h5>
    <p>Большая часть функций Apache реализуется при помощи модулей. При этом эти модули могут быть как «вшиты» в ту или иную сборку, так и загружаться в виде динамических библиотек (DSO). Большинство современных дистрибутивов поставляет Apache с набором DSO, так что не нужные модули можно отключить без перекомпиляции.</p>
    <p>Уменьшив количество модулей, Вы уменьшите объем потребляемой памяти. Если вы решили скомпилировать Apache самостоятельно, то либо тщательно подходите к выбору списка модулей, которые Вы хотите включить, либо скомпилируйте их как DSO, используя apxs в Apache1 и apxs2 в Apache2. Чтобы отключить ненужные DSO-модули, достаточно закомментировать лишние строчки LoadModule в httpd.conf. Если скомпилировать модули статически, Apache будет потреблять чуть меньше памяти, но Вам придется каждый раз его перекомпилировать, чтобы отключить или вкличить тот или иной модуль.</p>
    <h5>Выбирайте подходящий MPM</h5>
    <p>Для обработки запроса в Apache выделяется свой процессе или поток. Эти процессы работают в соответствии с одной из MPM (Мультипроцессорная модель). Выбор MPM зависит от многих факторов, таких как наличие поддержки потоков в ОС, объема свободной памяти, а также требований стабильности и безопасности.</p>
    <p>Если безопасность превыше производительности, выбирайте peruser или Apache-itk. Если важнее производительность, обратите внимание на prefork или worker.</p>
    <table class="table table-striped  table-bordered table-hover table-condensed">
        <tbody>
            <tr>
                <td>
                    Название
                </td>
                <td>
                    Разработчик
                </td>
                <td>
                    Поддерживаемые OS
                </td>
                <td>
                    Описание
                </td>
                <td>
                    Назначение
                </td>
                <td>
                    Статус
                </td>
            </tr>
            <tr>
                <td>
                    worker
                </td>
                <td>
                    Apache Software Foundation
                </td>
                <td>
                    Linux,  FreeBSD
                </td>
                <td>
                    Гибридная мультипроцессорно-мультипоточная модель. Сохраняя стабильность мультипроцессорных решений, она позволяет обслуживать большое число клиентов с минимальным использованием ресурсов.
                </td>
                <td>
                    Среднезагруженные веб-серверы.
                </td>
                <td>
                    Стабильный.
                </td>
            </tr>
            <tr>
                <td>
                    pre-fork
                </td>
                <td>
                    Apache Software Foundation
                </td>
                <td>
                    Linux,  FreeBSD
                </td>
                <td>
                    MPM, основанная на предварительном создании отдельных процессов, не использующая механизм threads.
                </td>
                <td>
                    Большая безопасность и стабильность за счёт изоляции процессов друг от друга, сохранение совместимости со старыми библиотеками, не поддерживающими threads.
                </td>
                <td>
                    Стабильный.
                </td>
            </tr>
            <tr>
                <td>
                    perchild
                </td>
                <td>
                    Apache Software Foundation
                </td>
                <td>
                    Linux
                </td>
                <td>
                    Гибридная модель, с фиксированным количеством процессов.
                </td>
                <td>
                    Высоконагруженные серверы, возможность запуска дочерних процессов используя другое имя пользователя для повышения безопасности.
                </td>
                <td>
                    В разработке, нестабильный.
                </td>
            </tr>
            <tr>
                <td>
                    netware
                </td>
                <td>
                    Apache Software Foundation
                </td>
                <td>
                    Novell NetWare
                </td>
                <td>
                    Мультипоточная модель, оптимизированная для работы в среде NetWare.
                </td>
                <td>
                    Серверы  Novell NetWare
                </td>
                <td>
                    Стабильный.
                </td>
            </tr>
            <tr>
                <td>
                    winnt
                </td>
                <td>
                    Apache Software Foundation
                </td>
                <td>
                    Microsoft Windows
                </td>
                <td>
                    Мультипоточная модель, созданная для операционной системы  Microsoft Windows.
                </td>
                <td>
                    Серверы под управлением  Windows Server.
                </td>
                <td>
                    Стабильный.
                </td>
            </tr>
            <tr>
                <td>
                    Apache-ITK
                </td>
                <td>
                    Steinar H. Gunderson
                </td>
                <td>
                    Linux,  FreeBSD
                </td>
                <td>
                    MPM, основанная на модели prefork. Позволяет запуск каждого виртуального хоста под отдельными  uid и  gid.
                </td>
                <td>
                    Хостинговые серверы, серверы, критичные к изоляции пользователей и учёту ресурсов.
                </td>
                <td>
                    Стабильный.
                </td>
            </tr>
            <tr>
                <td>
                    peruser
                </td>
                <td>
                    Sean Gabriel Heacock
                </td>
                <td>
                    Linux,  FreeBSD
                </td>
                <td>
                    Модель, созданная на базе MPM perchild. Позволяет запуск каждого виртуального хоста под отдельными  uid и  gid. Не использует потоки.
                </td>
                <td>
                    Обеспечение повышенной безопасности, работа с библиотеками, не поддерживающими threads.
                </td>
                <td>
                    Стабильная версия от  4 октября  2007 года, экспериментальная — от  10 сентября  2009 года.
                </td>
            </tr>
        </tbody>
    </table>
    <p>Для смены MPM требуется перекомпиляция Apache. Для этого удобнее взять source-based дистрибутив.</p>
    <h5>DNS lookup</h5>
    <p>Директива HostnameLookups включает обратные DNS запросы, при этом в логи пишутся dns-хосты клиентов вместо ip-адресов. Это существенно замедляет обработку запроса, т.к. запрос не обработается, пока не будет получен ответ от DNS-сервера. Следите, чтобы эта директива всегда была выключена (HostnameLookups Off). Если необходимы dns-адреса, можно «прогнать» лог в утилите logresolve.</p>
    <p>Кроме того, следите, чтобы в директивах Allow from и Deny From использовались ip-адреса а не доменные имена. В противном случае Apache будет делать два dns запроса (обратный и прямой), чтобы узнать ip и убедиться что клиент валиден.</p>
    <h5>AllowOverride</h5>
    <p>Если директива AllowOverride не установлена в None, Apache попытается открыть .htaccess файлы в каждой директории, которую он посещает и во всех директориях выше нее. Например:</p>
    <p>DocumentRoot /var/www/html</p>
    <p>&lt;Directory /var/www/html/&gt;</p>
    <p>AllowOverride all</p>
    <p>&lt;/Directory&gt;</p>
    <p>Если будет запрошен /index.html, Apache попытается открыть (и интерпретировать) файлы /.htaccess, /var/.htaccess, /var/www/.htaccess, и /var/www/html/.htaccess. Очевидно, что это увеличивает время обработки запроса. Так что, если вам нужен .htaccess только для одной директории, разрешите его только для нее:</p>
    <p>DocumentRoot /var/www/html</p>
    <p>&lt;Directory /&gt;</p>
    <p>AllowOverride None</p>
    <p>&lt;/Directory&gt;</p>
    <p>&lt;Directory /var/www/html/&gt;</p>
    <p>AllowOverride all</p>
    <p>&lt;/Directory&gt;</p>
    <h5>FollowSymLinks и SymLinksIfOwnerMatch</h5>
    <p>Если для каталога включена опция FollowSymLinks, Apache будет следовать по символическим ссылкам в этом каталоге . Если включена опция SymLinksIfOwnerMatch, Apache будет следовать по символическим ссылкам, только если владелец файла или каталога на которую указывает эта ссылка, совпадает с владельцем указанного каталога. Поэтому при включенной опции SymLinksIfOwnerMatch Apache делает больше системных запросов. Кроме того, дополнительные системные запросы требуются, когда FollowSymlinks не определен. Следовательно, наиболее оптимальным для производительности будет включение опции FollowSymlinks, конечно, если политика безопасности позволяет это сделать.</p>
    <h5>Content Negotiatio</h5>
    <p>Механизм, определенный в HTTP спецификации, который позволяет обслуживать различные версии документа (представления ресурса), для одного и того же URI, чтобы клиент смог определить, какая версия лучше соответствует его возможностям. Когда клиент отправляет запрос на сервер, то сообщает серверу, какие типы файлов он понимает. Каждому типу соответствует рейтинг, описывающий насколько хорошо клиент его понимает. Таким образом, сервер, способен предоставить версию ресурса, который наилучшим образом соответствует потребностям клиента.</p>
    <p>Нетрудно понять, чем это грозит для производительности сервера, поэтому избегайте применения content negotiaion.</p>
    <h5>MaxClients</h5>
    <p>Директива MaxClients устанавливает максимальное количество параллельных запросов, которые будет поддерживать сервер. Значение MaxClient не должно быть слишком маленьким, иначе многим клиентам будет отказано. Нельзя устанавливать слишком большое количество – это грозит нехваткой ресурсов и «падением» сервера. Ориентировочно, MaxClients = количество памяти выделенное под веб-сервер / максимальный размер порожденного процесса или потока. Для статических файлов Apache использует около 2-3 Мб на процесс, для динамики (php, cgi) – зависит от скрипта, но обычно около 16-32 Мб. Если сервер уже обслуживает MaxClients запросов, новые запросы попадают в очередь, размер которой устанавливается директивой ListenBacklog.</p>
    <h5>MinSpareServers, MaxSpareServers, и StartServers</h5>
    <p>Создание потока, и особенно процесса – ресурсоемкая операция, поэтому Apache создает их про запас. Директивы MaxSpareServers и MinSpareServers устанавливают минимальное и максимальное число процессов/потоков, которые должны быть готовы принять запрос. Если значение MinSpareServers слишком мало и пришло много запросов, Apache начнет создавать много новых процессов/потоков, что создаст лишнюю нагрузку в пиковые моменты. Если MaxSpareServers слишком велико, Apache будет излишне нагружать систему, даже если число запросов минимально.</p>
    <p>Опытным путем нужно попдобрать такие значения, чтобы Apache не создавал более 4 процессов/потоков в секунду. Если он создаст более 4, в ErrorLog будет сделана соответствующая запись – сигнал того что MinSpareServers нужно увеличить.</p>
    <h5>MaxRequestsPerChild</h5>
    <p>Директива MaxRequestsPerChild определяет максимальное число запросов, которое может обработать один дочерний процесс/поток прежде чем он завершиться. По умолчанию значение установлено в 0, что означает, что не будет завершен никогда. Рекомендуется установить MaxRequestsPerChild равное числу запросов за час. Это не создаст лишней нагрузки на сервер и, в то же время, поможет избавиться от проблем с утечкой памяти в дочерних процессах (например, если вы используете нестабильную версию php).</p>
    <h5>KeepAlive и KeepAliveTimeout</h5>
    <p>KeepAlive позволяет делать несколько запросов в одном TCP-подключении. При использовании схемы frontend+backend, эти директивы не актуальны.</p>
    <p>HTTP-сжатие</p>
    <p>Сейчас все современные клиенты и практически все сервера поддерживают HTTP-сжатие. Использование сжатия позволяет понизить трафик между клиентом и сервером до 4-х рах, повышая при этом нагрузку на процессор сервера. Но, если сервер посещает много клиентов с медленными каналами, сжатие способно снизить нагрузку посредством уменьшения времени передачи сжатого ответа. При этом ресурсы, занятые дочерним процессом освобождаются быстрее, и уменьшается число одновременных запросов. Это особенно заметно в условиях ограничения памяти.</p>
    <p>Отмечу, что не следует устанавливать степень сжатия gzip более 5, так как существенно возрастает нагрузка на процессор, а степень сжатия растет незначительно. Также, не следует сжимать файлы, формат которых уже подразумевает сжатие – это практически все мультимедийные файлы и архивы.</p>
    <h5>Кеширование на стороне клиента</h5>
    <p>Не забывайте устанавливать Expires заголовки для статических файлов (модуль mod_expires). Если файл не изменяется, то всегда следует дать указание клиенту закэшировать его. При этом у клиента будут быстрее загружаться страницы, а сервер избавиться от лишних запросов.</p>
    <h5>Отключение логов</h5>
    <p>Отключение логов помогает временно справиться с нагрузкой в пиковые моменты. Эта мера существенно сокращает нагрузку на все виды ПО и является универсальным средством в критической ситуации. Естественно, при очевидных недостатках, не может рекомендоваться к применению и служит лишь временным решением проблемы.</p>
    <h3>Nginx</h3>
    <p>Простой и легкий веб-сервер, специально предназначенный для обработки статических запросов. Причина его производительности в том, что рабочие процессы обслуживают одновременно множество соединений, мультиплексируя их вызовами операционной системы select, epoll ( Linux) и kqueue ( FreeBSD). Сервер имеет эффективную систему управления памятью с применением пулов. Ответ клиенту формируется в буферах, которые хранят данные либо в  памяти, либо указывают на отрезок файла. Буферы объединяются в цепочки, определяющие последовательность, в которой данные будут переданы клиенту. Если операционная система поддерживает эффективные операции ввода-вывода, такие как <strong> writev</strong> и <strong> sendfile</strong> , то <strong> Nginx, </strong> по возможности, применяет их.</p>
    <p>При использовании в связке с Apache, Nginx настраивается на обработку статики и используется для балансировки нагрузки. Подавляющее время занимается лишь тем, что отдает статический контент, делает это очень быстро и с минимальными накладными расходами.</p>
    <h3>Lighttpd</h3>
    <p>«Веб-сервер, разрабатываемый с расчётом на быстроту и защищённость, а также соответствие стандартам.» – википедия</p>
    <p>Является альтернативой Nginx и применяется для тех же целей.</p>
    <h3>Акселераторы PHP</h3>
    <p>Принцип работы таких продуктов в том, что они кэшируют байт-код скрипта и позволяют снизить нагрузку на интерпретатор PHP.</p>
    <h5>Существующие решения</h5>
    <p>The Alternative PHP Cache —был задуман, как бесплатный, открытый и стабильный фреймворк для кэширования и оптимизации исходного кода PHP. Поддерживает PHP4 и PHP5, включая 5.3.</p>
    <p>eAccelerator — это свободный открытый проект, выполняющий также роли акселератора, оптимизатора и распаковщика. Имеет встроенные функции динамического кэширования контента. Имеется возможность оптимизации PHP-скриптов. Поддерживает PHP4 и PHP5, включая 5.3.</p>
    <p>PhpExpress бесплатный ускоритель обработки PHP скриптов на веб-сервере. Также обеспечивает поддержку загрузки файлов закодированных через Nu-Coder. Поддерживает PHP4 и PHP5, включая 5.3</p>
    <p>XCache поддерживает PHP4 и PHP5, включая 5.3. Начиная с версии 2.0.0 (release candidate от 2012-04-05) включена поддержка PHP 5.4.</p>
    <p>Windows Cache Extension for PHP - PHP-акселератор для Microsoft IIS (BSD License). Поддерживает только PHP (5.2 и 5.3).</p>
    <h4>Логика кэширования</h4>
    <p>«Кэшировать, кэшировать и еще раз кэшировать!» - вот девиз высоконагруженной системы.</p>
    <p>Давайте представим себе идеальный высоконагруженный сайт. Сервер получает http запрос от клиент. Frontend сопоставляет запрос с физическим файлом на сервере и, если тот существует, отдает его. Загрузку скриптов и картинок опустим, так как это в большинстве своем статика и отдается по такому же принципу. Далее, если физически файл не существует, frontend обращается с этим запросом к backend-у, который занимается обработкой логики (скриптов php и т.д.). Backend должен решить кэшировать ли данный запрос и создать файл в определенном месте, который и будет отдаваться frontend-ом в дальнейшем. Таким образом, мы навсегда закэшировали данный запрос и сервер будет обрабатывать его максимально быстро с минимально возможной нагрузкой на сервер.</p>
    <p>Данный идеальный пример подходит для страниц, содержание которых не меняется с течением времени, либо меняется редко. На практике же мы имеем страницы, содержимое которых может меняться с каждым последующим запросом. Вернее часть этого содержимого. Примером такого содержимого может служить пользовательская информация, которая должна меняться с незаметной для пользователя задержкой или отображаться в реальном времени (обновляться при каждой перезагрузке страницы). Тут перед нами возникает задача, которая сводится к разделению динамических и статических данных на странице.</p>
    <p>Самым удобным и распространенным способом разделения данных является разделение страницы на блоки. Это логично и удобно, ведь страница, с точки зрения верстки, состоит из блоков. Избежать логики в этом случае естественно не получится, но логика эта будет обрабатываться с наименьшими затратами.</p>
    <p>Таким образом, запрос клиента (кроме запроса статики) переадресуется на backend и его обработка сводится к следующим действиям:</p>
    <ol>
        <li>Получение информации о блоках, которые будут на странице.</li>
        <li>Проверка информации о кэшах для каждого блока. Кэш может не существовать или нуждаться в обновлении. В этом случае генерируем файл кэша. Если блок не должен кэшироваться выполняем соответствующую логику. Информацию о кэшах можно хранить в nosql базе данных или в файловой структуре. Тут требование одно: получение этой информации должно занимать минимум ресурсов.</li>
        <li>Формируем html страницы. Закэшированные блоки встраиваем при помощи ssi инструкции (вставляется ссылка на файл кэша), что позволит существенно экономить память.</li>
        <li>Страница попадает на frontend, который производит замену всех ssi инструкций на содержимое файлов и отдает страницу клиенту.</li>
    </ol>
    <p>Также, распространенным является кэширование результатов выполнения функции или метода класса. При этом, мы передаем кэширующей функции ссылку на объект (если вызываем метод), имя метода или функции (если это глобальная функция) и параметры, предназначающиеся этому методу или функции. Кэширующая функция проверит наличие файла кэша, при необходимости, сформирует его или прочтет, а затем вернет результат.</p>
    <p>Это общее описания принципа работы высоконагруженного сайта. Конкретная реализация будет отличаться деталями, но концепция останется прежней.</p>
    <h4>Картинки, пикчи, тумбочки</h4>
    <p>Оказывается изображение тоже можно кэшировать. Зачем? Спросите Вы. В принципе, после загрузки на сервер у нас уже есть файл, который frontend быстренько выплюнет при необходимости. Но часто нам требуется получить на основе уже имеющейся картинки другое изображение (например, других размеров). Допустим, нам нужна миниатюра изображения – thumbnail (тумбочка жарг.). В этом случае, нам достаточно сформировать путь к бедующему файлу уменьшенной картинки и отдать страницу клиенту.</p>
    <ol>
        <li>Клиент, получив исходный код страницы, начинает подгружать статику и обращается с запросом на несуществующую пока картинку к frontend-у.</li>
        <li>Frontend переадресует запросы к несуществующим изображениям на backend.</li>
        <li>Backend анализирует запрос, формирует файл изображения и отдает бинарные данные с соответствующим http-заголовком.</li>
        <li>Все последующие запросы будут отдаваться frontend-ом.</li>
    </ol>
</div>
<br/>